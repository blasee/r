---
title: Putting it all together
teaching: 25
exercises: 25
questions:
  - "How can I use multiple data verbs together?"
  - "How should I plan my data analysis?"
objectives:
  - "Break down an analysis into several small steps"
  - "Understand approaches to linking analysis steps together."
  - "Use the pipe (`%>%`) to chain together multiple functions in a readable format."
keypoints:
  - "Data analyses can be broken down into discrete stages"
  - "Most data analysis stages fit into a small number of types"
  - "Pipes pass their left hand side through as the first argument of the right hand side."
  - "Pipes make your code more readable, but be careful of going overboard."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("13-")

library(tidyverse)
gapminder <- read_csv("data/gapminder.csv")
```

Now that we have learned some data manipulation verbs you might begin to see how they 
could be used together. By combining several small and simple steps you can start to perform complex
manipulations.

> ## Challenge 1
> Using both `select()` and `filter()`, create a data frame containing only the `country`, `year`, and 
> `pop` columns for Australian data.
{: .challenge}

Your solution to this challenge probably took one of two approaches:

#### Using an intermediate variable
~~~~
filtered_data <- filter(data, ...)

final_data <- select(filtered_data, ...)
~~~~
{: .language-r}

#### Nesting function calls
~~~~
final_data <- select(filter(data, ...), ...)
~~~~
{: .language-r}

Each of these are perfectly acceptable ways to solve the problem, but can lead to code that is 
difficult to read and understand. In the case of the intermediate variables, you need to come up 
with a name for each one, and if you aren't very careful about keeping the connected lines of code 
together it can become difficult to track which variable is being used in each function. The nested
version removes some of these problems, but it's hard enough to read with only two simple steps.

## Piping in R
From the [magrittr](https://magrittr.tidyverse.org) package in the tidyverse we have another approach
for chaining a sequence of functions. This is the pipe operator (`%>%`), which works in a similar 
way to the unix pipe.

> ## Shortcuts
> Typing `%>%` in everytime you want a pipe is a bit awkward, so RStudio has a shortcut to help.
> Use <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd> (<kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd> 
> on a Mac) to insert a pipe into your code.
{: .callout}

## Using the pipe
The pipe works by taking the output of it's left hand side and inserting it as the first argument 
to the function on it's right hand side.

This means that the following
~~~~
some_function(data)
~~~~
{: .language-r}
could be rewritten using a pipe as
~~~~
data %>% some_function()
~~~~
{: .language-r}
Other function arguments are left untouched so
~~~~
#Standard form
some_function(data, first_arg, second_arg)

#Piped form
data %>% some_function(first_arg, second_arg)
~~~~
{: .language-r}
are equivalent.

> ## Challenge 2
> Rewrite the following line from the previous lesson in a piped form. Does it give you the same 
> output?
>
> `filter(gapminder, country == "Australia", year >= 1997)`
> > ## Solution to Challenge 2
> > ``` {r piping-sol-2}
> > gapminder %>% 
> >     filter(country == "Australia", year >= 1997)
> > ```
> {: .solution}
{: .challenge}

## Combining
The real value of the pipe comes when there are multiple steps to complete. To rewrite our example 
above using pipes:
~~~~
#Nested form
final_data <- select(filter(data, ...), ...)

#Piped form
final_data <- data %>% 
                filter(...) %>% 
                select(...)
~~~~
{: .language-r}

This can be read as a series of instructions. Take the data frame `data`, *then* `filter` it to keep
some rows, *then* `select` some columns. 

For many people, the piped form is one that is easier to read and understand, as well as easier to 
write. 

> ## Challenge 3
> Take your answer to Challenge 1 and rewrite it in a piped form.
> 
> Now, imagine that you have decided later more steps are required. Add a step renaming the `pop`
> column to `population` for both forms. Do you find one form easier to work with than the other?
> > ## Solution to Challenge 3
> > For the piped version:
> > ``` {r piping-sol-3-1}
> > gapminder %>% 
> >     select(country, year, pop) %>% 
> >     filter(country == "Australia")
> > ```
> > And adding a rename step:
> > ``` {r piping-sol-3-2}
> > gapminder %>% 
> >     select(country, year, pop) %>% 
> >     filter(country == "Australia") %>% 
> >     rename(population = pop)
> > ```
> {: .solution}
{: .challenge}

## Common pitfalls
When using pipes to construct a sequential analysis, there are a few problems that can trip people up.

#### Failing to complete the pipe
When constructing a sequence by adding or removing steps, a very common problem is that you will leave
a pipe command trailing at the end of your code block.

~~~~
#Pipe to nowhere
final_data <- data %>% 
                filter(...) %>% 
                select(...) %>% 
~~~~
{: .language-r}

In this case, your code will not complete and R will pause and wait for the rest of the pipe before 
continuing. This is easy to spot in your console because the input indicator will change from a `>`
to a `+`, telling you that R is waiting for you to complete a command. Just hit the <kbd>Esc</kbd>
key to cancel the command, and fix up your pipe before running it again.

#### Forgetting to assign the output
This has been covered before, but is something that often gets forgotten again once you start using
pipes. If the final output of your pipe is not saved into a variable, it will just get printed to 
the screen and then lost.

So instead of 
~~~~
gapminder %>% 
  select(country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
~~~~
{: .language-r}

make sure to save the output if you need access to it later
~~~~
aust_data <- gapminder %>% 
  select(country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
~~~~
{: .language-r}

#### Forgetting to pass some data in to the pipe
Some people have the opposite problem where they focus so much on getting each step of the pipe right
that they forget that it needs some data to work on.

Try running the pipe above without any data:
```{r piping-error}
select(country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
```
It throws an error because `select()` in the first step is expecting it's first argument to be a 
data frame that it can work on. Instead, it finds `country`, which is not a data frame.

You could fix this by providing the data frame directly to select
~~~~
select(gapminder, country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
~~~~
{: .language-r}

But it is easier to know exactly what data is going into a pipe if you put it on it's own line at 
the start
~~~~
gapminder %>% 
  select(country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
~~~~
{: .language-r}

#### Overly long pipes
Using pipes can make your code more understandable, but there is a limit to their effectiveness. If
your pipe has too many steps it becomes harder to read through and keep in your memory all the steps 
that have been applied to the data. 

It also makes identifying errors harder. Imagine a pipe with 30 steps that is giving 
you the wrong output or throwing an error. Working out which of those 30 steps is the cause of the 
problem can become time consuming and difficult. If you find yourself writing very long pipes, 
consider if there are any logical ways to break it up into a series of smaller pipes.

## Style questions
There are a couple of guidelines about style you can use when writing pipes to make them more 
understandable

#### Separate each step in a pipe
Each step of the pipe should be on a separate line, and all steps after the first should be indented.
This helps to clearly identify the elements of the pipe and read through them in a step-by-step 
fashion.

#### Comment sensibly
You *can* add comments into the middle of a pipe chain

~~~~
gapminder %>% 
  rename(gdpPerCap = gdpPercap) %>% # Inconsistent capitalisation annoys me
  select(country, year, gdpPerCap) %>% 
  # Data version of #MapsWithoutNZ
  filter(country != "New Zealand")
~~~~
{: .language-r}

but consider the effect those comments have on the legibility of your code. It may be best to add
your comment at the start of the pipe instead. Or to break the pipe up so that the complicated parts
needing comments are separated from the simpler steps.

## Constructing an analysis
We have now learned a number of tools for manipulating data, as well as a convenient way to link
them together. When it comes time to put them together, it can help to start at the end. Decide on 
what your end goal is, and then work backwards step by step to figure out how to achieve it. As an 
example using the gapminder data, suppose a colleague asked you which country had the sixth highest 
population in 1972. In order to  answer that, you would need a list of the countries ordered by their 
population in 1972. To get such a list, you would first need to extract just the data from 1972 from
the complete gapminder set. And to extract just the 1972 data (assuming you are doing this analysis 
in R), you would first need to import the data from somewhere.

So this very basic analysis has a number of steps to complete:

  * Read gapminder data into R
  * Keep only the data from 1972
  * Sort this data by population size
  * Get the sixth highest population size
  * Look at the country with that population
  
> ## Challenge 4
>
> Using this process, what steps might you need to determine which countries are in the top 
> ten life expectancy lists for both 1987 and 2007?
{: .challenge}  
  
## From design to implementation
  
Once you have sketched out an analysis, you will have a series of small, self contained steps to 
complete. This maps well onto the [tidyverse philosophy](https://tidyverse.tidyverse.org/articles/manifesto.html)
that each function should be as simple as possible, and do one thing well. Ideally each of your 
analysis steps will correspond to one (or a small number) of tidyverse verbs that we have covered. 
For example, we could take our analysis from before and add in some tidyverse verbs without losing 
the descriptiveness.

  * `read_csv` the gapminder data into R
  * `filter` only the data from 1972 
  * `arrange` this data by population size
  * `filter` the sixth highest population size
  * `select` the country variable with that population
  
As you become familiar with these functions and the 'grammar' of the tidyverse, it will become easier
to see how to link them together step by step to complete an analysis. Eventually this process will
become second nature and you will easily be able to break down complex analyses into a series of 
small steps that can solved using a handful of simple functions.

> ## Challenge 5
> Try and map some tidyverse verbs onto the steps you identified in [Challenge 4](#challenge-4). 
> How many verbs did you need for each step?
>
> Now, see if you can implement them in code to answer the question.
{: .challenge} 
